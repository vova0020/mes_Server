# Система аудита и аналитики MES

## Добавленные таблицы

### 1. **EventLog** - Единая таблица событий
Хранит все события системы в одном месте для быстрого поиска.

**Поля:**
- `eventType` - тип события (ORDER_CREATED, MACHINE_STATUS_CHANGED и т.д.)
- `entityType` - тип сущности ("order", "machine", "pallet", "part", "package")
- `entityId` - ID сущности
- `userId` - кто выполнил действие
- `oldValue` / `newValue` - старое и новое значение (JSON)
- `metadata` - дополнительные данные (JSON)

### 2. **MachineStatusHistory** - История статусов станков
Отслеживает все изменения статусов станков (ACTIVE ↔ INACTIVE ↔ MAINTENANCE ↔ BROKEN).

**Что фиксируется:**
- Старый и новый статус
- Кто изменил
- Причина изменения
- Длительность в предыдущем статусе (секунды)

**Что можно получить:**
- Сколько времени станок был в каждом статусе
- Когда и кто менял статус
- Простои станка
- История поломок

### 3. **MachineOperationHistory** - История операций на станках
Полная история всех операций, выполненных на станках.

**Что фиксируется:**
- Какой станок
- Какой поддон и деталь обрабатывались
- Какой этап маршрута
- Количество обработанных деталей
- Время начала и завершения
- Оператор
- Длительность операции

**Что можно получить:**
- Производительность станка
- Среднее время обработки
- Количество обработанных деталей за период
- Эффективность операторов
- Загрузка станка

### 4. **OrderStatusHistory** - История статусов заказов
Отслеживает все изменения статусов заказов.

**Что фиксируется:**
- Старый и новый статус
- Кто изменил
- Причина изменения

**Что можно получить:**
- Полная история заказа
- Время в каждом статусе
- Задержки и их причины

### 5. **PartStatusHistory** - История статусов деталей
Отслеживает изменения статусов деталей по маршруту.

**Что фиксируется:**
- Старый и новый статус
- На каком этапе маршрута
- На каком станке

**Что можно получить:**
- Маршрут детали с временными метками
- Время на каждом этапе
- Узкие места в производстве

### 6. **PalletMovementHistory** - История перемещений поддонов
Полная история всех перемещений поддонов.

**Что фиксируется:**
- Откуда и куда перемещен
- Тип перемещения (TO_BUFFER, TO_MACHINE, TO_PACKAGE)
- Количество
- Кто переместил

**Что можно получить:**
- Полный путь поддона
- Время в каждой локации
- Кто и когда перемещал

### 7. **PackageStatusHistory** - История статусов упаковок
Отслеживает изменения статусов упаковок.

**Что фиксируется:**
- Старый и новый статус
- Кто изменил

**Что можно получить:**
- Время упаковки
- Задержки в упаковке

### 8. **ReclamationHistory** - История рекламаций
Расширенная история всех действий с рекламациями.

**Что фиксируется:**
- Действие (CREATED, CONFIRMED, RESOLVED)
- Старый и новый статус
- Кто выполнил
- Комментарий

**Что можно получить:**
- Полная история рекламации
- Время обработки
- Кто и что делал

### 9. **DefectStatsByMachine** - Статистика брака по станкам
Агрегированная статистика брака.

**Что фиксируется:**
- Станок
- Деталь
- Тип брака
- Количество
- Когда обнаружен
- На каком этапе

**Что можно получить:**
- Статистика брака по станкам
- Статистика брака по типам деталей
- Статистика брака по этапам
- Динамика брака
- Топ-10 причин брака

### 10. **OperatorPerformanceStats** - Статистика производительности операторов
Агрегированная статистика по операторам (по дням).

**Что фиксируется:**
- Оператор
- Станок
- Дата
- Количество обработанных деталей
- Количество брака
- Время работы (минуты)

**Что можно получить:**
- Производительность каждого оператора
- Качество работы (% брака)
- Сравнение операторов
- Эффективность по дням/неделям/месяцам

## Примеры использования

### Получить историю станка
```typescript
const history = await prisma.machineStatusHistory.findMany({
  where: { machineId: 1 },
  orderBy: { createdAt: 'desc' },
  include: { user: true }
});
```

### Получить производительность станка за период
```typescript
const operations = await prisma.machineOperationHistory.findMany({
  where: {
    machineId: 1,
    completedAt: {
      gte: new Date('2024-01-01'),
      lte: new Date('2024-01-31')
    }
  }
});

const totalQuantity = operations.reduce((sum, op) => 
  sum + Number(op.quantityProcessed), 0
);
```

### Получить маршрут детали
```typescript
const partHistory = await prisma.partStatusHistory.findMany({
  where: { partId: 1 },
  orderBy: { createdAt: 'asc' },
  include: {
    routeStage: { include: { stage: true } },
    machine: true
  }
});
```

### Получить статистику брака по станку
```typescript
const defects = await prisma.defectStatsByMachine.groupBy({
  by: ['machineId', 'defectType'],
  where: {
    detectedAt: {
      gte: new Date('2024-01-01'),
      lte: new Date('2024-01-31')
    }
  },
  _sum: { quantity: true }
});
```

### Получить производительность оператора
```typescript
const performance = await prisma.operatorPerformanceStats.findMany({
  where: {
    operatorId: 1,
    date: {
      gte: new Date('2024-01-01'),
      lte: new Date('2024-01-31')
    }
  },
  include: { machine: true }
});
```

## Миграция

После внесения изменений в schema.prisma выполните:

```bash
npx prisma migrate dev --name add_audit_system
npx prisma generate
```

## Следующие шаги

1. Создать сервис для автоматического логирования событий
2. Создать интерсепторы для отслеживания изменений
3. Создать API endpoints для получения аналитики
4. Создать дашборды для визуализации данных
